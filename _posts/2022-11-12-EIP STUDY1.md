---
layout: post
title: 정보처리기사
subtitle: 정보처리기사 1장 요구사항 확인
cover-img: /assets/img/path.jpg
thumbnail-img: /assets/img/thumb.png
share-img: /assets/img/path.jpg
tags: [정보처리기사, JDMJ, study, 자격증, 정리]
---

# 1장 요구사항 확인

# 1. 소프트웨어 생명 주기

## -  소프트웨어 생명 주기(Software Life Circle)

소프트웨어를 개발하기 위한 설계, 운영, 유지보수 등의 과정을 각 단계 별로 나눈 것이다.

**1) 폭포수 모형(Waterfall Model)**

각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론

가장 오래되고, 전통적인 소프트웨어 생명 주기, 고전적 생명 주기 모형

다음 단계를 수행하기 위한  결과물이 명확하게 산출

**2) 프로토 타입 모형(Prototype Model)**

실제 개발될 소프트웨어에 대한 견본품(prototype)을 만들어 최종 결과물을 예측하는 모델

**3) 나선형 모형(Spiral Model)**

여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 형

보헴(Boehm)

유지보수 필요 없음

계획 수립 → 위험 분석 → 개발 및 검증 → 고객 평가

**4) 애자일 모형(Agile Model)**

민첩한, 기민한

고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발하는 모형

고객과의 소통을 초점

1. 개인과 상호작용에 더 가치를 둠
2. 실행되는 SW 에 더 가치를 둠
3. 고객과 협업 에 더 가치를 둠
4. 변화에 반응 에 더 가치를 둠

- **스크럼(Scrum)**
    
    팀이 중심이되어 개발의 효율성을 높이는 기법 (럭비 대치)
    
    | 제품 책임자(PO) | 백로그(모든 요구사항의 우선순위 목록) 를 작성하는 주체, 
    이해도 높음, 의사 결정 |
    | --- | --- |
    | 스크럼 마스터(SM) | 가이드 역할 |
    | 개발팀(DT) | 제품 개발 |
    
    **계획 > 진행(스프린트) > 회의 > 검토 > 회고**
    
    | 스프린트 계획 회의 | 백로그 중, 수행할 작업을 대상으로 단기일정 수립 |
    | --- | --- |
    | 스프린트 | 실제 개발 작업을 진행 |
    | 일일 스크럼 회의 | 진행 상황을 점검, 소멸차트에 표시 |
    | 스프린트 검토 회의 |  테스팅 단계 |
    | 스프린트 회고 | 규칙 준수 여부 및 개선할 점을 확인하고 기록 |
- **XP(eXtreme Programming)**
    
    요구사항을 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발생산성을 향상시키는 방법
    
    1. 의사소통(Communication)
    2. 단순성(Simplicity)
    3. 용기(Courage)
    4. 존중(Respect)
    5. 피드백(Feedback)
    
    **릴리즈(Release)**
    
    몇 개의 요구사항이 적용되어 부분적으로 기능이 완료된 제품을 제공
    
    **계획 >  진행(이터레이션) > 검사 > 출시(릴리즈)**
    
    릴리즈 계획 수립 >  이터레이션 > 승인 검사 > 소규모 릴리즈
    
    | Pair Programming
    (짝 프로그래밍) | 다른 사람과 함께 프로그래밍을 수행함으로 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성 |
    | --- | --- |
    | Collective Ownership
    (공동 코드 소유) | 개발 코드에 대한 권한과 책임을 공동을 소유 |
    | Test-Driven
    Development
    (테스트 주도 개발) | 실제 코드를 작성하기 전, 테스트 케이스를 먼저 작성
    자동화된 테스팅 도구(구조, 프레임 워크)를 사용 |
    | Whole Team
    (전체 팀) | 개발에 참여하는 모든 구성원(고객 포함)들은 각자 자신의 역할이 있고 그 역할에 대한 책임을 가져야 함 |
    | Continuous Intergration
    (계속적인 통합) | 개발된 코드들은 하나의 작업이 마무리 될 때마다 지속적으로 통합 |
    | Refactoring
    (리팩토링) | 프로그램 기능의 변경 없이 시스템을 재구성
    프로그램 쉽게 이해 및 수정하여 빠르게 개발 도모 |
    | Small Releases
    (소규모 릴리즈) | 릴리즈 기간을 짧게 반복함으로써 요구 변화에 신속히 대응 |
- 칸반(Kanban)
- Lean
- 기능 중심 개발(FDD; Feature Driven Development)

**5)** **소프트웨어 공학 (SE; Software Engineering)**

소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문

1. 현대 프로그래밍 기술을 계속해서 적용
2. 품질이 유지되도록 지속적으로 검증
3. 명확한 기록을 유지

# 2. 현행 시스템 파악

시스템 > 소프트웨어 > 하드웨어

# 3.개발 기술 환경 파악

운영체제(OS), 데이터베이스 관리 시스템(DBMS), 미들웨어 등을 선정할 때 고려해야 할 사항을 기술, 오픈 소스를 사용할 때 주의해야 할 내용을 제시

- **운영체제(OS, Operating System)**
    
    컴퓨터 시스템의 자원을 효율적으로 관리하며, 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어
    
- **데이터베이스 관리 시스템(DBMS, DataBase Management System)**
    
    사용자와 DB 사이에서 사용자의 요구에 다라 정보를 생성해주고, DB를 관리해주는 SW
    
    데이터의 종속성과 중복성 해결
    
    가용성, 성능, 기술 지원, 상호 호환성, 구축 비용
    
- **웹 애플리케이션(WAS, Web Application Server)**
    
    동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어, DB 서버와 연동
    
    가용성, 성능, 기술지원, 구축비용
    
- **오픈소스(Open Source)**
    
    제한 없이 사용할 수 있도록 소스 코드를 공개한 소프트웨어
    
    라이선스 종류, 사용자 수, 기술의 지속 가능성
    

# 4. 요구사항

### 요구사항이란?

소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 운영되는데 필요한 제약조건

- **기능 요구사항(Functional requirements)**
    
    기능이나 수행과 관련된 요구사항, 시스템이 반드시 수행해야 하는 기능, 제공받기 원하는 기능
    
- **비기능 요구사항(Non-Functional requirements)**
    
    품질이나 제약사항과 관련된 요구사항
    
- **사용자 요구사항(User requirements)**
    
    사용자 관점에서 본 시스템이 제공해야 할 요구사항(친숙)
    
- **시스템 요구사항(System requirements)**
    
    개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항(전문)
    

### 요구사항 개발 프로세스

요구사항을 체계적으로 도출하고 분석한 후 명세서에 정리한 다음 확인 및 검증하는 일련의 구조화된 활동

**도출 > 분석 > 명세 > 확인**

1. **요구사항 도출 (Requirement Elicitation)**
    
    시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항을 어떻게 수집할 것인지 식별하고 이해하는 과정 (이해관계자, Stakeholder)
    SDLC(소프트웨어 개발  생명 주기) 동안 지속적으로 반복
    
    -청취와 인터뷰, 설문, 브레인스토밍, 워크샵, 프로토타이핑, 유스케이스
    
2. **요구사항 분석 (Requirement Analysis)**
    
    요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 걸러내기 위한 과정
    
    개발 대상에 대한 사용자의 요구사항을 이해하고 문서화 하는 활동, 비용 일정에 대한 제약 설정
    
    - **구조적 분석 기법**
        
        자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법, 하향식 방법
        
        - **자료 흐름도(DFD; Data Flow Diagram)**
            
            자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법 
            
            ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled.png)
            
        - **자료 사전(DD; Data Dictionary)**
            
            자료 흐름도에 있는 자료를 정의하고 기록한 것
            
            ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%201.png)
            
    
    - **요구사항 분석용 CASE(자동화 도구)**
        
        요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 도구
        
        | SADT | - 시스템 정의, 분석, 설계를 위한 도구
        - SoftTech  사에서 개발
        - 구조적 요구 분석, 블록 다이어그램 |
        | --- | --- |
        | SREM = RSL/REVS | - TRW 사가 실시간 처리 소프트웨어 시스템에서 요구사랑을 명확히 기술할 목적으로 개발한 도구
        - RSL/REVS를 사용하는 자동화 도구 |
        | PSL/PSA | - PSL 과 PSA 를 사용하는 도구 |
        | TAGS | - 시스템 공학 방법 응용에 대한 자동 접근 방법 |
    - **HIPO(Hierarchy Input Process Output)**
        
        시스템의 분석 및 설계, 또는 문서화에 사용되는 기법
        시스템 실행 과정인 입력 처리 출력의 기능을 표현, 하향식
        의존관계를 동시에 표현
        
        기호, 도표 사용하여 이해 쉬움
        
        - HIPOChart 종류
            
            **가시적 도표(Visual Table of Contents)** 
            
            [https://t1.daumcdn.net/cfile/tistory/2227A73D5622584B1F](https://t1.daumcdn.net/cfile/tistory/2227A73D5622584B1F)
            
            **총체적** **도표(Overview Diagram)** 
            
            [https://t1.daumcdn.net/cfile/tistory/2654254C562258600B](https://t1.daumcdn.net/cfile/tistory/2654254C562258600B)
            
            **세부적 도표(Detail Diagram)** 
            
            [https://t1.daumcdn.net/cfile/tistory/25296F475622587606](https://t1.daumcdn.net/cfile/tistory/25296F475622587606)
            
        
3. **요구사항 명세** (**Requirement Specification)**
    
    분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것
    
    | 정형 명세 기법 |  비정형 명세 기법 |
    | --- | --- |
    | 수학적 원리 기반, 모델 기반 | 상태/기능/객체 중심 |
    | 수학적 기호, 정형화된 표기법 | 일반 명사, 동사 등의 자연어를 기반으로 서술 또는 다이어그램으로 작성 |
    | - 요구사항을 정확하고 간결하게 표현할 수 있음
    - 일관성이 있어 완전성 검증이 가능
    - 표기법이 어려워 사용자가 이해하기 어려움 | - 자연어의 사용, 일관성 떨어짐, 해석이 달라짐
    - 의사소통이 용이함 |
    | VDM, Z, Petri-net, CSP 등 | FSM, Decision, Table, ER모델링, State Chart 등 |
4. **요구사항 확인** (**Requirement Validation)**
    
    요구사항 명세서가 정확하고 완전하게 작성되었는지를 검토하는 활동(이해관계자들이 검토)
    
5. **요구공학**(**Requirements Engineering)**
    
    요구사항을 정의하고, 분석 및 관리하는 프로세스를 연구하는 학문, 프로젝트 실패 최소화
    

# 5. UML(Unified Modeling Language)

### UML(Unified Modeling Language)

시스템 개발 과정에서 의사소통이 원할하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어

Rumbaugh, Booch, Jacobason 

OMG(Object Management Group)에서 표준으로 지정

**UML의 구성요소**

사물(Things), 관계(Relationships), 다이어그램(Diagram)

### 1. 사물(Things)

다이어그램 안에서 관계가 형성될 수 있는 대상들

| 구조 사물
(Structural Things) | - 시스템의 개념적, 물리적 요소를 표현
- 클래스, 유스케이스, 컴포넌트, 노드 등 |
| --- | --- |
| 행동 사물
(Behavioral Things) | - 시간과 공간에 따른 요소들의 행위를 표현
- 상호작용(Interaction), 상태 머신(State Machine)등 |
| 그룹 사물
(Grouping Things) | - 요소들을 그룹으로 묶어서 표현
- 패키지 |
| 주해 사물
(Annotation Things) | - 부가적인 설명이나 제약조건 등을 표현
- 노트(Note) |

### 2. 관계(Relationships)

사물과 사물 사이의 연관성을 표현

- **연관(Association) 관계**
    
    2개 이상의 사물이 서로 관련되어 있는 관계
    
    실선으로 연결
    
    ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%202.png)
    
    ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%203.png)
    
    ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%204.png)
    
- **집합(Aggregation) 관계**
    
    하나의 사물이 다른 사물에 포함되어 있는 관계
    
    ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%205.png)
    
- **포함(Composition) 관계**
    
    포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계
    
    ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%206.png)
    
- **일반화(Generalization) 관계**
    
    하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계
    
    ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%207.png)
    
- **의존(Dependency) 관계**
    
    서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계
    
    ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%208.png)
    
- **실체화(Realization) 관계**
    
    할 수 있거나 해야 하는 기능으로, 서로를 그룹화 할 수 있는 관계
    
    ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%209.png)
    

### 3. 다이어그램(Diagram)

사물과 관계를 도형으로 표현한 것

**정적 모델링** : 사용자가 요구한 기능을 구현하는데 필요한 자료들의 논리적인 구조를 표현 

객체(Object)들을 클래스(Class)로 추상화하여 표현

**동적 모델링** : 시스템 내부 구성 요소들의 상태 변화 과정과 과정에서 발생하는 상호 작용을 표현

(동작 관점, View, 오퍼레이션을 통한 상호 작용에 초점)

**기능 모델링 :** 개발될 시스템이 갖춰야 할 기능을 정리한 후 사용자와 함께 정리된 내용을 공유하기 위해 그림으로 표현하는 것 (기능 초점)

 

- **구조적(Structural) 다이어그램**
    1. **클래스 다이어그램 (Class Diagram)**
        
        클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현
        
        **연관 클래스**
        
        연관 관계에 있는 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스
        
        ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%2010.png)
        
        [Class 다이어그램](https://www.notion.so/Class-9b0706259cb64cab821022e3184279fc)
        
    2. **객체 다이어그램 (Object Diagram)**
        
        인스턴스(Instance)를 특정 시점의 객체와 객체 사이의 관계로 표현
        
    3. **컴포넌트 다이어그램 (Component Diagram)**
        
        컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 구현 (구현 단계)
        
    4. **배치 다이어그램 (Deployment Diagram)**
        
        물리적 요소들의 위치를 표현 (구현 단계)
        
    5. **복합체 구조 다이어그램 (Composite Structure Diagram)**
        
        복합 구조를 갖느 ㄴ경우 그 내부 구조를 표현
        
    6. **패키지 다이어그램 (Package Diagram)**
        
        그룹화한 패키지들의 관계를 표현
        
        [Package 다이어그램](https://www.notion.so/Package-5024067787fd4dfea6382daf7b6ffab5)
        
- **행위(Behavioral) 다이어그램  (동적)**
    1. **유스케이스 다이어그램 (Use Case Diagram)** 기능모델링 ****
        
        사용자의 요구를 분석, 사용자(Actor), 사용사례(Use Case)
        
        개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현
        
        [Use Case 다이어그램](https://www.notion.so/Use-Case-edefb8ec35b3444fbd86fd048b3c3665)
        
    
    1. **시퀀스 다이어그램 (Sequence Diagram)** 동적모델링
        
        시스템이나 객체들이 메세지를 주고 받으며 상호 작용 하는 과정을 그림으로 표현
        
        [Sequence 다이어그램](https://www.notion.so/Sequence-a3db4c8af69a45869640a2b956e88911)
        
    2. **커뮤니케이션 다이어그램 (Communication Diagram)**
        
        시스템이나 객체들이 메시지를 주고받으며 상호작용하는 과정과 객체들 간의 연관을 그림으로 표현
        
        [Communication 다이어그램](https://www.notion.so/Communication-c27f169358664a5a8dc49de3f7bd48ca)
        
    
    1. **상태 다이어그램 (State Diagram)**
        
        **럼바우(Rumbaugh)** 객체지향 분석 기법에서 활용
        
        객체들 사이에 발생하는 이벤트에 의한 객체들의 상태 변화를 그림으로 표현, 속성 값의 변화
        
        [State 다이어그램](https://www.notion.so/State-83a0fe4badc14eed9521e1399e8ef198)
        
    2. **활동 다이어그램 (Activity Diagram)** 기능모델링 ****
        
        사용자의 관점에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현
        
        (자료흐름도와 유사)
        
        [Acticity 다이어그램](https://www.notion.so/Acticity-5cdcad817dae48ef9bb1d4a4d1c81b65)
        
    3. **상호작용 개요 다이어그램 (Interaction Overview Diagram)**
        
        상호작용 다이어그램 간의 제어 흐름을 표현
        
    4. **타이밍 다이어그램 (Timing Diagram)**
        
        객체 상태 변화와 시간 제약을 명시적으로 표현
        
- **스테레오 타입 (Stereotype)**
    
    UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현 하는 것
    
    길러멧 ( **≪ ≫** )
    
    | ≪ include ≫ | 포함 관계 |
    | --- | --- |
    | ≪ extends ≫ | 확장 관계 |
    | ≪ interface ≫ | 인터페이스를 정의 |
    | ≪ exception ≫ | 예외를 정의 |
    | ≪ constructor ≫ | 생성자 역할 |

# 6. 소프트웨어 개발 방법론

소프트웨어 개발, 유지보수 등에 필요한 수행방법과 각종 기법 및 도구를 체계적으로 정리하여 표준화한 것

- **구조적 방법론**
    
    사용자의 요구사항을 파악하여 문서화 하는 처리(Precess) 중심의 방법론
    
    분할과 정복(Divide and Conquer) 
    
    **타당성 검토 > 계획 > 요구사항 > 설계 > 구현 > 시험 > 운영/유지보수**
    
- **정보공학 방법론**
    
    계획, 분석, 설계, 구축에 정형화된 기법들을 통합 및 적용하는 자료(Data) 중심의 방법론
    
    대규모 정보 시스템을 구축
    
    **정보 전략 계획 수립 > 업무 영역 분석 > 업무 시스템 설계 > 업무 시스템 구축**
    
- **객체지향 방법론**
    
    현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체(Object)로 만들어, 기계의 부품을 조립하듯이 객체들을 조립해서 필요한 소프트웨어를 구현하는 방법론
    
    **요구 분석 > 설계 > 구현 >  테스트 및 검증 > 인도**
    
    - **구성 요소**
        
        객체, 클래스, 메시지 등
        
    - **기본 원칙**
        
        캡슐화, 정보 은닉, 추상화, 상속성, 다형성 등
        
- **컴포넌트 기반(CBD)  방법론**
    
    컴포넌트(문서, 소스코드 등 모듈화된 자원)를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론
    
    **개발 준비 > 분석 > 설계 > 구현 > 테스트 > 전개 > 인도**
    
    - 재사용 가능
    - 시간과 노력을 절감
    - 확장성 보장
    - 유지보수 비용 최소화
    - 생산성 및 품질 향상
    
- **제품 계열 방법론**
    
    제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
    
    임베디드 소프트웨어에 적합
    
    - **영역공학**
        
        영역 분석, 영역 설계, 핵심 자산을 구현
        
    - **응용공학**
        
        제품 요구 분석, 제품 설계, 제품을 구현
        

- **애자일 방법론**
    
    

# 7. S/W 공학의 발전적 추세

### 소프트웨어 재사용(Software Reuse)

이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것

품질과 생산성을 높이기 위한 방법

- **합성 중심 (Composition-Based)**
    
    블록을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법, 블록 구성 방법
    
- **생성중심 (Generation-Based)**
    
    추상화 형태로 써진 명세를 구체화하여 프로그램을 만드는 방법, 패턴 구성 방법
    

### 소프트웨어 재공학(Software Reengineering)

기존 시스템을 이용하여 보다 나은 시스템을 구착하고, 새로운 기능을 추가하여 소프트웨어 성능을 향상시키는 것

개조 및 개선을 통해 유지보수성과 품질을 향상

- 품질향상
- 생산성 증가
- 수명연장
- 오류감소

### CASE(Computer Aided Software Enginerring)

소프트웨어 개발 과정에서 사용되는 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것

자동화 도구(CASE Tool)

개발 도구와 방법론이 결합

생산성 향상을 구현

- 생명 주기 전 단계의 연결
- 개발 모형 지원
- 그래픽 지원

# 8. 비용 산정 기법

**소프트웨어 비용 산정**

개발 계획 수립에 필요한 비용을 산정

높게 설정 ⬆️ : 일의 효율성 저하를 초래

낮게 설정 ⬇️ : 개발자의 부담이 가중되고 품질 문제가 발생

- **소프트웨어 비용 결정 요소**

| 프로젝트 요소 | - 제품 복잡도 : 소프트웨어의 종류에 따라 발생할 수 있는 문제점들의 난이도
- 시스템 크기 : 소프트웨어의 규모에 따라 개발해야 할 시스템의 크기
- 요구되는 신뢰도 : 일정 기간 내 주어진 조건하에서 프로그램이 필요한 기능을 수행하는 정도 |
| --- | --- |
| 자원 요소 | - 인적 자원 : 소프트웨어 개발 관련자들이 갖춘 능력 혹은 자질
- 하드웨어 자원 : 소프트웨어 개발 시 필요한 장비와 워드프로세서, 프린터 등의 보조 장비
- 소프트웨어 자원 : 소프트웨어 개발 시 필요한 언어 분석기, 문서화 도구 등의 개발 지원도구 |
| 생산성 요소 | - 개발자의 능력 : 개발자들이 닺춘 전문지식, 경험, 이해도, 책임감, 창의력  등
- 개발 기간 :  소프트웨어를 개발하는 기간  |
- **하향식 비용 산정 기법**
    
    과거의 유사한 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정
    
    - **전문가 감정 기법**
        
        경험이 많은 두 명 이상의 전문가에게 비용 산정을 의뢰하는 기법
        
        가장 편리, 신속하게 비용 산정, 믿음, 주관적
        
    - **델파이 기법**
        
        전문가 감정 기법의 주관적인 편견을 보완하기 위해 많은 전문가 의견을 종합하여 산정
        
        한 명의 조정자와 여러 전문가로 구성
        
- **상향식 비용 산정 기법**
    
    세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정
    
    - **LOC(원시 코드 라인 수, source Line  Of Code) 기법**
        
        각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구한 후 이용하여 비용을 산정, 가장 많이 사용
        
        <aside>
        💡 예측치 = 낙관치 + 4*비관치 + 기대치(중간치) / 6
        
        </aside>
        
        .
        
        <aside>
        💡 **산정공식
        - 노력(인월) =** 개발 기간 X 투입 인원 = LOC/ 1인당 월평균 생산 코드 라인 수
        - **개발 비용 =** 노력(인월) / 단위 비용(1인당 월평균 인건비)
        - **개발 기간 =** 노력(인월) / 투입 인원
        - **생산성 =** LOC/노력(인월)
        
        </aside>
        
    - **개발 단계별 인월수 기법**
        
        각 기능을 구현시키는 데 필요한 노력을 생명 주기의 각 단계별로 산정
        
        LOC 기법보다 더 정확
        
    - **수학적 산정 기법**
        
        경험적 추정 모형, 실험적 추정 모형
        
        개발  비용 산정의 자동화를 목표, 과거의 유사한 프로젝트를 기반으로 유도
        
        - **COCOMO 모형**
            
            LOC(원시 코드 라인 수)에 의한 비용 산정 기법
            
            규모(LOC)를 예측한 후 이를 소프트웨어 종류에 따라 다르게 책정되는 비용 산정 방정식에 대입하여 비용 산정
            
            보헴(Boehm)이 제한
            
            - **COCOMO의 소프트웨어 개발 유형**
                
                
                | 조직형
                (Organic Mode) | - 중 소 규모의 소프트웨어
                - 5만(50KDSI) 라인 이하의 소프트웨어 개발
                -사무 처리, 업무, 과학 응용 소프트웨어 개발에 적합 |
                | --- | --- |
                | 반분리형
                (Semi-Datached Mode) | - 조직형과 내장형의 중간형 소프트웨어
                - 30만(300KDSI) 라인 이하의 소프트웨어 개발
                - 컴파일러, 인터프리터와 같은 유틸리티 개발에 적합 |
                | 내장형
                (Embedded Mode) | - 초대형 규모의 소프트웨어
                - 30만(300KDSI) 이상의 소프트웨어 개발
                - 신호기 제어, 미사일 유도 시스템 등 |
            - **COCOMO  모형의 종류**
                
                
                | 기본형(Basic)
                COCOMO | 소프트웨어의 크기와 개발 유형만을 이용하여 비용 산정 |
                | --- | --- |
                | 중간형(Intermediate)
                COCOMO | 기본형 COCOMO의 공식을 토대로 사용하나 다음 4가지 특성에 의해 비용을 산정함
                - 제품의 특성
                - 컴퓨터의 특성
                - 개발 요원의 특성
                - 프로젝트 특성 |
                | 발전형(Detailed)
                COCOMO | 중간형 COCOMO 보완
                자세하고 정확하게 노력을 산출
                개발 과정의 후반부에 주로 적용 |
        
        - **Putnam 모형**
            
            소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형
            
            생명 주기 예측 모형, 대형 프로젝트에서 이용
            
            Rayleigh-Norden 곡선의 노력 분포도  ****
            
            개발 기간이 늘어날수록 프로젝트 적용 인원의 노력이 감
            
            ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%2011.png)
            
        - **기능 점수(FP; Function Point) 모형**
            
            소프트웨어의 기능을 증대시키는 요인별로 가중치를 부여
            
            - 소프트웨어 기능 증대 요인
                - 자료입력(입력양식)
                - 정보 출력(출력 보고서)
                - 명령어(사용자 질의수)
                - 데이터 파일
                - 필요한 외부 루틴과의 인터페이스
            
            총 기능 점수와 영향도를 이용하여 기능 점수(FP)를 구한 후 이를 이용해서 비용을 산정
            
            알브레히트(Albrecht) 제안
            
        
        - 비용 산정 자동화 추정 도구
            
            
            | SLIM | Rayleigh-Norden 곡선과 Putnam 모형 예측 모델을 기초로 하여 개발된 자동화 도구 |
            | --- | --- |
            | ESTIMACS | 다양한 프로젝트와 개인별 요소를 수용하도록 FP모형을 기초로 하여 개발된 자동화 추정 도구 |

# 9. 프로젝트 일정 계획

### 프로젝트 일정(Scheduling) 계획

각 소작업에 분배하여 소작업의 순서와 일정을 정하는 것

- **PERT(Program Evaluation and Review Technique, 프로그램 평가 및 검토 기술)**
    
    전체 작업의 상호 관계를 표시하는 네트워크, 비용 측정은 고려 안함
    
    소요 기간 예측이 어려운 프로젝트 일정 계획에 사용
    
    낙관치(빨리 진행될 경우), 기대치(정상적일 경우), 비관치(장애 생길 경우)
    
    ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%2012.png)
    
    - 종료시기
        - 낙관적인 경우
        - 가능성이 있는 겨우
        - 비관적인 경우
- **CPM(Critical Path Method, 임계 경로 기법)**
    
    작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용하는 기법, 최장 경로
    
    ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%2013.png)
    
- **간트 차트**
    
    프로젝트의 작업 일정을 막대 도표를 이용하여 표시하는 프로젝트 일정표
    
    시간선(Time-Line) 차트
    
    ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%2014.png)
    

# 10. 소프트웨어 개발 방법론 결정

- **소프트웨어 개발 방법론 결정**
    
    프로젝트 관리와 재사용 현황을 소프트웨어 개발 방법론에 반영
    
    소프트웨어 생명 주기와 개발 방법론에 맞춰 소프트웨어 개발 단계, 활동, 절차 등을 정의
    
    1. 프로젝트 관리와 재사용 현황을 방법론에 반영
    2. 개발 단계별 작업 및 절차를 소프트웨어 생명 주기에 맞춰 수립
    3. 결정된 소프트웨어 개발 방법론의 개발 단계별 활동 목적, 작업 내용, 산출물에 대한 매뉴얼을 작성
    
- **프로젝트 관리(Project Management)**
    
    최소의 비용으로 시스템을 개발하기 위한 전반적인 활동
    
    | 일정 관리 | 작업 순서, 작업 기간 산정, 일정 개발, 일정 통제 |
    | --- | --- |
    | 비용 관리 | 비용 산정, 비용 예산 편성, 비용 통제 |
    | 인력 관리 | 프로젝트 팀 편성, 자원 산정, 프로젝트 조직 정의, 프로젝트 팀 개발, 자원 통제, 프로젝트 팀 관리 |
    | 위험 관리 | 위험 식별, 위험 평가, 위험 대처, 위험 통제 |
    | 품질 관리 | 품질 계획, 품질 보증 수행, 품질 통제 수행 |

# 11. 소프트웨어 개발 표준

### 소프트웨어 개발 표준

소프트웨어 개발 단계에서 수행하는 품질 관리에서 사용되는 국제 표준

- **ISO/IEC 12207**
    
    ISO(국제표준화기구)에서 만든 표준 소프트웨어 생명 주기 프로세스
    
    표준을 제공
    
    | 기본 생명 주기 프로세스 | 획득, 공급, 개발, 운영, 유지보수 프로세스 |
    | --- | --- |
    | 지원 생명 주기 프로세스 | 품질 보증, 검증, 확인, 활동, 검토, 감사, 문서화, 형상 관리, 문제 해결 프로세스 |
    | 조직 생명 주기 프로세스 | 관리, 기반 구조, 훈련, 개선 프로세스 |
- **CMMI(능력 성숙도 통합 모델)**
    
    소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델
    
    카네키 🍈 연구소 (SEI)
    
    | 초기(Initial) | 정의된 프로세스 없음 | 작업자 능력에 따라 성공 여부 결정 |
    | --- | --- | --- |
    | 관리(Managed) | 규칙화된 프로세스 | 특정한 프로젝트 내의 프로세스 정의 및 수행 |
    | 정의(Defined) | 표준화된 프로세스 | 조직의 표준 프로세스를 활용하여 업무 수행 |
    | 정량적 관리
    (Quantitatively
    Managed) | 예측 가능한 프로세스 | 프로젝트를 정량적으로 관리 및 통제 |
    | 최적화
    (Optimizing) | 지속적 개선 프로세스 | 프로세스 역량 향상을 위해 지속적으로 프로세스 개선 |
- **SPICE(소프트웨어 처리 개선 및 능력 평가 기준)**
    
    소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선 국제표준
    
    **ISO/IEC 15504**
    
    - SPICE 구성
    
    | 고객-공급자
    (Customer-
    Supplier)
    프로세스 | - 소프트웨어를 개발하여 고객에게 전달하는 것을 지원하고, 소프트웨어의 정확한 운용 및 사용을 위한 프로세스로 구성
    - 구성요소 : 인수, 공급, 요구 도출, 운영
    - 프로세스 수 : 10개 |
    | --- | --- |
    | 공학
    (Engineering)
    프로세스 | - 시스템과 소프트웨어 제품의 명세화, 구현, 유지보수를 하는데 사용되는 프로세스로 구성됨
    - 구성요소 : 개발, 소프트웨어 유지보수
    - 프로세스 수 : 9개 |
    | 지원
    (Support)
    프로세스 | - 소프트웨어 생명 주기에서 다른 프로세스에 의해 이용되는 프로세스로 구성됨
    - 구성요소 : 문서화, 형상, 품질 보증, 검증, 확인, 리뷰, 감사, 품질 문제 해결
    - 프로세스 수 : 8개 |
    | 관리
    (Management)
    프로세스 | - 소프트웨어 생명 주기에서 프로젝트 관리자에 의해 사용되는 프로세스로 구성됨
    - 구성요소 : 관리, 프로젝트 관리, 품질 및 위험 관리
    - 프로세스 수 :  4개 |
    | 조직
    (Organization)
    프로세스 | - 조직의 업무 목적 수립과 조직의 업무 목표 달성을 위한 프로세스로 구성됨
    - 구성 요소 : 조직 배치, 개선 활동 프로세스, 인력 관리, 기반 관리, 측정 도구, 재사용
    - 프로세스 수 : 9개 |
    - **SPICE의 프로세스 수행 능력 단계**
    
    | 불완전(Incomplete) | 프로세스가 구현되지 않았거나 목적을 달성하지 못한 단계 |
    | --- | --- |
    | 수행(Performed) | 프로세스가 수행되고 목적이 달성된 단계 |
    | 관리(Managed) | 정의된 자원의 한도 내에서 그 프로세스가 작업 산출물을 인도하는 단계 |
    | 확립(Established) | 소프트웨어 공학 원칙에 기반하여 정의된 프로세스가 수행되는 단계 |
    | 예측(Predictable) | 프로세스가 목적 달성을 위해 통제되고, 양적인 측정을 통해서 일관되게 수행되는 단계 |
    | 최적화(Optimizing) | 프로세스 수행을 최적화하고, 지속적인 개선을 통해 업무 목적을 만족시키는 단계 |

# 12. 소프트웨어 개발 방법론 테일러링

**소프트웨어 개발 방법론 테일러링**

소프트웨어 개발 방법론의 절차, 사용기법 등을 수정 및 보완하는 작업

1. 프로젝트 특징 정의
2. 표준 프로세스 선정 및 검증
3. 상위 수준의 커스터마이징
4. 세부 커스터마이징
5. 테일러링 문서화

- 고려사항
    
    
    | 내부적
    기준 | - 목표 환경 : 시스템의 개발 환경과 유형이 서로 다른 경우 테일러링이 필요함
    - 요구사항 : 개발, 운영, 유지보수 등 프로젝트에서 우선적으로 고려할 요구사항이 서로 다른 경우 테일러링이 필요
    - 프로젝트 규모 : 비용, 인력, 기간 등 프로젝트의 규모가 서로 다른 경우 테일러링이 필요함
    - 보유 기술 : 프로세스, 개발방법론, 산출물, 구성원의 능력 등이 서로 다른 경우 테일러링이 필요함 |
    | --- | --- |
    | 외부적
    기준 | - 법적 제약사항 : 프로젝트별로 적용될 IT Compliance 가 서로 다른 경우 테일러링이 필요
    - 표준 품질 기준 : 금융, 제도 등 분야별 표준 품질 기준이 서로 다른 경우 테일러링이 필요 |

# 13. 소프트웨어 개발 프레임워크

소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여

 제공해주는 반제품 형태의 소프트웨어 시스템

- 소프트웨어 개발 프레임워크의 주요 기능
    - 예외처리
    - 트랜잭션 처리
    - 메모리 공유
    - 데이터 소스 관리
    - 서비스 관리
    - 쿼리 서비스
    - 로깅 서비스
    - 사용자 인증 서비스
    
- 소프트웨어 개발 프레임워크의 종류
    - **스프링 프레임워크(Spring Framework)**
        
        자바 플랫폼을 위한 오픈 소스 경량형 애플리케이션 프레임워크
        
        동적인 웹 사이트의 개발, 전자정부의 기반
        
        ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%2015.png)
        
    - **전자정부 프레임워크**
        
        대한민국의 공공부문 정보화 사업 시 효율적인 정보 시스템의 구축을 지원하기 위해 필요한
        
        기능 및 아키텍처를 제공하는 프레임워크
        
        오픈 소스 기반의 범용화
        
        특정 업체의 종속성을 배제, 사업별 공통 컴포넌트의 중복 개발을 방지
        
        ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%2016.png)
        
    - **닷넷 프레임워크(.NET Framework)**
        
        Windows 프로그램의 개발 및 실행 환경을 제공하는 프레임워크
        
        CLR 가상머신 상에서 작동
        
        ![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%AD%E1%84%80%E1%85%AE%E1%84%89%E1%85%A1%E1%84%92%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%209bcafa8c8b7a44c0aee04a9cafc66900/Untitled%2017.png)
        
- 소프트웨어 개발 프레임워크의 특성

| 모듈화
(Modularity) | - 캡슐화를 통해 모듈화를 강화하고 설계 및 구현의 변경에 따른 영향을 최소화함으로써 품질 향상
- 모듈화로 인해 유지보수가 용이 |
| --- | --- |
| 재사용성
(Reusablility) | - 재사용 가능한 모듈들을 제공함으로써 예산 절감, 생산성 향상, 품질 보증이 가능 |
| 확장성
(Extensibility) | - 다형성(Polymorphism)을 통한 인터페이스 확장이 가능하여 다양한 애플리케이션 개발 가능 |
| 제어의 역흐름
(Inversion of Control) | - 객체들의 제어를 프레임워크에 넘김으로써 생산성을 향상 |